### Методы проектирования
**Тест-дизайн** - это этап процесса тестирования ПО, на котором проектируются и создаются тестовые сценарии (тест-кейсы), в соответствии с определенными ранее критериями качества и целями тестирования.

### Тест-дизайн на основе метода черного ящика
Методы черного ящика (также известные как методы, основанные на спецификации) опираются на анализ заданного для объекта тестирования поведения безотносительно его внутреннего устройства.
Таким образом, тестовые сценарии не зависит от программной реализации. Как следствие, когда меняется программная реализация, но не меняется требуемое поведение, тестовые сценарии остаются применимы.

**Техники тест-дизайна, основанные на использования черного ящика, включают:**
	- Классы эквивалентности
	- Анализ граничных значений
	- Таблицы решений
	- Диаграммы изменения состояния
	- Попарное тестирование
	- Тестирование по сценариям использования

### Эквивалентное разбиение

**Пример:**
Требуется написать программу для отделе кадров, которая определяла бы возможность приема кандидата в зависимости от его возраста по следующим требованиям:
	- от 0 до 16 - не принимаются
	- от 16 до 18 - могут быть приняты только на неполный рабочий день,
	- от 18 до 55 - могут быть приняты как штатные сотрудники на полный рабочий день
	- от 56 - не принимаются
Способы реализации:
	- Каждый возраст через if
	- Через промежутки if
	- Добавление секретного персонажа с заплатой сто тыщ миллионов

Входные данные для программного обеспечения или системы разбиваются на группы, от которых ожидается сходное поведение, то есть они должны обрабатываться одинаково. Эквивалентные области могут быть определены как допустимые (валидных), так и для недопустимых (невалидных) данных, то есть тех знаний, которые должны отвергаться

- **Позитивные (валидные) значения** - это значения, которые должны быть принят
- **Негативные (невалидные значения)** - это значения, которые должны быть отвергнуты

 - Классы могут быть определены для любых данных, относящихся к объекты тестирования, включая: входные данные, выгодные данные, внутренние данные, данные, связанные со временем
- Любой класс может быть при необходимости разделен на подклассы
- Каждое значение может принадлежать одному классы


**Пример эквивалентного разбиения:**
Ипотечная корпорация выдает ипотеки физическим лицам с доходами от 30 тыс. до 5 млн. рублей в месяц. Одному физическому лицу разрешено брать от 1 до 5 единиц жилья. По "жильем" подразумевается квартира или частный дом.
Составить тестовые наборы для проверки данных условий, используя технику эквивалентного разбиения. 
Классы:
	- доход - [30 тыс.; 50 тыс.] (невалид 20)
	- вид лица -  физическое (невалид юридическое)
	- вид жилья - частный или квартира (невалид чердак)
	- единицы жилья [1 ; 5] (невалид 6)
Нужно проверять каждый класс проверять по отдельности для нахождения ошибок.

### Анализ граничных значений
 Поведение на границах эквивалентных областей имеет наибольшие шансы быть некорректным, таким образом, границы являются потенциальным источником дефектов. Минимальные и максимальные значения сегмента являются **граничные значения**. Граничное значение для валидного сегмента является валидным граничным значением, для невалидного сегмента - невалидным. ![[Pasted image 20241025135928.png]]
 Если нер-во нестрогое - 3 значения (<= 3 черточки)
 Если нер-во строгое - 2 значения (< две черточки)


### Таблица решений
Таблица решений также известна как таблица причинно-следственных связей. Этот метод тестирования программного обеспечения используется для функций, которые реагируют на комбинацию входов или событий. Например, кнопка отправки должна быть включена, если пользователь ввел все обязательные поля.

**Применение техники таблицы принятия решений**
	1. Определить и записать все условия
	2. Подсчитать количество возможных комбинаций условий
	3. Заполнить комбинации
	4. Записать действия
	5. Убрать лишние комбинации
![[Pasted image 20241025141333.png]] 
**Пример таблицы решений:**
Расчет скидки для страховки студентов.
![[Pasted image 20241025141417.png]] ![[Pasted image 20241025141522.png]]

###  Тестирование состояний и переходов
Воспроизводит модель поведения системы. показывая возможные состояния и разрешенные переходы между этими состояниями. Любой переход вызывается событием, которое может к тому же сопровождаться ограничением. Подразумевается, что переходы происходят мгновенно и в некоторых случаях вызывают определенные действия программы. Диаграммы перехода состояний обычно показывают только допустимые переходы и исключают недействительные переходы.
**Диаграмма перехода состояний**
- **Состояния** (круг, фигура) - состояние, в котором система ожидает возникновения одного или нескольких событий.
- **Переход** (стрелка) - изменение состояния из одного в другое, произошедшее благодаря какому-то событию.
- **Событие** (надпись над стрелкой перехода) - что-то, что вызывается изменение состояния системы.
- **Действие** (команда, следующая за "/") - операция, которая вызвана изменением состояния.
**Пример с банкоматом**:
![[Pasted image 20241025142711.png]]
Сценарий тестирования, основанный либо на диаграмме перехода состояний, либо на таблице переходов, обычно представлен последовательностью событий, которые приводят к последовательности переходов между состояниями
	Покрытие состояний - придумать сценарии чтобы проверить все состояния
	Покрытие разрешенных переходов
	Покрытие всех переходов
**Таблица перехода состояния**
![[Pasted image 20241025143536.png]] ![[Pasted image 20241025143553.png]]
### Попарное тестирование
**Попарное тестирование**
Метод основан на следующей идее: подавляющее большинство багов выявляется тестом, проверяющим либо один параметр, либо сочетание двух. Ошибки, причиной которых явились комбинации трех и более параметров, как правило, значительно менее критичны.

**Попарное тестирование** (pairwise testing) - разработка тестов методом черного ящика, в которой тестовые сценарии разрабатываются таким образом, чтобы выполнить все возможные отдельные комбинации каждой пары входных параметров.
![[Pasted image 20241025143905.png]] ![[Pasted image 20241025143923.png]] ![[Pasted image 20241025144812.png]] ![[Pasted image 20241025144830.png]]

### Сценарии использования
Сценарии использования  
Преимущества  
- Позволяют выявить функциональные требования системы с точки зрения пользователя  
- Могут быть использованы для активного вовлечения пользователей в процесс сбора требований и определений  
Аналитики
![[Pasted image 20241101133551.png]] Тестировщики ![[Pasted image 20241101133611.png]]

### Тестирование методом белого ящика
**Тестирование методом белого/прозрачного ящика** - тестирование, основанное на анализе внутренней структуры компонента или системы.

Метод предполагает, что внутренняя структура/устройство/реализация системы известны тестировщику.

Принципиальное преимущество всех методом белого ящика заключается в том, что при тестирование во внимание берется полная программная реализация, что повышается выявляемость де

- Покрытие кода
- Покрытие сегментов
- Покрытие ветвей или тестирование узлов
- Покрытие составных условий

Что дает тестирование белым ящиком
	- Все независимые пути в модуле были выполнены по крайней мере один раз
	- Все логические решения проверяются на их истинные и ложные значения
	- Все циклы выполняются на своих границах и в пределах своих рабочих границ
	- Исследование структуры внутренних данных для проверки их достоверности

Недостатки
	- Количество путей может быть слишком велико
	- выбранные тесты могут не содержать данные, чувствительные к ошибкам (y = x * 2 вместо y = x ^ 2)
	- Программа может делать не то, что нужно
	- может быть пропущен какой-то маршрут

Техники тест-дизайна, основанные на использования белого ящика, включают:
	- Покрытие операторов (программа прошла все строчки кода)
	- Покрытие альтернатив (решений)
	- Покрытие условий
	- Покрытие решений/условий
	- Комбинаторное покрытие условий
	- Покрытие путей

### Покрытие операторов
**Критерий покрытия операторов**
Необходимо подобрать такое количество тестов, чтобы каждый оператор в программе был выполнен хотя бы один раз
**Покрытие операторов** - доля операторов, проверенных во времени выполнения набора сценариев тестирование
![[Pasted image 20241101134059.png]]**Пример**
![[Pasted image 20241101134201.png]]
### Покрытие альтернатив/решений/ветвей
**Тестирование решений** - разработка тестов методом белого ящика, в котром тестивые сценарии проектирруются для проверки результатов альтернативы.
**Критерий покрытия альтеранатив (решений)**
Необходимо подобрать такое количество тестов, чтобы каждое направление перехода было реализовано по крайней мере один раз.
**Покрытие решений** измеряется как число результатов принятие решений, выполненных тестами, деленное на общее число результатов принятия решений. ![[Pasted image 20241101135153.png]]
**Примечание**
![[Pasted image 20241101135604.png]]
### Покрытие условий
**Покрытие условий** 0 требуется разработки такого количества, тестов, чтобы каждое простое условие получило бы и значение  "Истина", и значение "Ложь" хотя бы один раз.
Как правило, покрытие условий лучше, чем покрытие альтернатив, потому что каждое отдельное условие проверяется как минимум один раз.
**Пример**
![[Pasted image 20241101140057.png]]

### Покрытие решений/условий
Требует подобрать такое количество тестов, чтобы каждая ветвь в программе была пройдена хотя бы один раз и чтобы каждое простое условие получило и значение "Истина", и значение "Ложь" хотя бы один раз.
**Недостатки метода:**
	- Не всегда можно проверить все условия
	- Невозможно проверить условия, которые скрыты другими условиями
	- Недостаточная чувствительность к ошибкам в сложных условиях и логических выражений

### Комбинаторное покрытие условий
**Комбинаторное покрытие условий** требует такое числа тестов, чтобы любая комбинация простых условий выполнялась хотя бы один раз.

**Пример** ![[Pasted image 20241101141149.png]] ![[Pasted image 20241101141619.png]]

### Покрытие путей (не используется, так как трудоемко)
**Покрытие путей** - проверяет все пути выполнения программы пройдены хотя бы один раз.
Используется для тестирования фрагментов сложного кода, который включает операторы цикла или комбинации... *(не успела)*
**Этапы структурного тестирования**:
	- Получение графа потока управления от программного модуля
	- Вычисление цикломатической сложности графа (С)
	- Получение набора основных маршрутов, количество которых равно С
	- Создание тестов для каждого основного маршрута
	- Выполнение этих тестов
![[Pasted image 20241101142421.png]]
**Цикломатическая сложность** - это конечное минимальное количество независимых, нециклических маршрутов (называемые основными маршрутами), которые могут образовывать все возможные линейные пути в программном модуле.
С точки зрения графа потока, каждый основой маршрут проходит как минимум через одно ребро, в которое нет никакого другого пути. ![[Pasted image 20241101142800.png]]
[[Пример]]

### Тестирование на основе опыта
**Техники**:
	- Предугадывание ошибок
	- Исследовательское тестирование 
	- Тестирование на основе контрольного списка

**Предугадывание ошибок**
Наиболее часто используемым методом, основанный на опыте. Зачастую тестировщики ожидают дефекты, исходя из своего опыта.
Предугадывание - этот метод, используемый для прогнозирования ошибок, дефектов и сбоев на основе знаний тестера о том:
	- Как раньше работало приложение
	- Какие типы ошибок обычно делают разработчики
	- Какие ошибки были в других приложениях

**Исследовательское тестирование**
Исследовательское тестирование - это параллельная разработка тестов, их выполнение, протоколирование тестирования и изучение, основанные на концепции тестирования, включающей в себя цели тестирования, и проводимые в определенных временных рамках.

**Тестирование на основе контрольного списка**Тестирование проходит по заранее составленному контрольному списку.  
В рамках анализа тестировщики могут изменять и дополнять список.  
Контрольные списки составляются на основе опыта, знаний о том, что важно для пользователя, или понимания причин сбоя программного обеспечения.